<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,Programming Language,">










<meta name="description" content="标准模板库(STL) C++11所有容器类型: deque, list, queue, priority_queue, stack, vector, map, multimap, set, multiset, bitset(比特级处理数据的容器), forward_list(单向链表), unordered_map, unordered_multimap, unordered_set, unord">
<meta name="keywords" content="C++,Programming Language">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记-标准模板库和新特性">
<meta property="og:url" content="https://stardust-blog.cn/笔记/C-学习笔记-标准模板库和新特性/index.html">
<meta property="og:site_name" content="Stardust&#39;s Blog">
<meta property="og:description" content="标准模板库(STL) C++11所有容器类型: deque, list, queue, priority_queue, stack, vector, map, multimap, set, multiset, bitset(比特级处理数据的容器), forward_list(单向链表), unordered_map, unordered_multimap, unordered_set, unord">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://stardust-blog.cn/笔记/C-学习笔记-标准模板库和新特性/lambda_expression.png">
<meta property="og:updated_time" content="2018-12-21T15:54:44.093Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++学习笔记-标准模板库和新特性">
<meta name="twitter:description" content="标准模板库(STL) C++11所有容器类型: deque, list, queue, priority_queue, stack, vector, map, multimap, set, multiset, bitset(比特级处理数据的容器), forward_list(单向链表), unordered_map, unordered_multimap, unordered_set, unord">
<meta name="twitter:image" content="https://stardust-blog.cn/笔记/C-学习笔记-标准模板库和新特性/lambda_expression.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://stardust-blog.cn/笔记/C-学习笔记-标准模板库和新特性/">





  <title>C++学习笔记-标准模板库和新特性 | Stardust's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Stardust's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Live in thinking</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://stardust-blog.cn/笔记/C-学习笔记-标准模板库和新特性/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stardust">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stardust's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++学习笔记-标准模板库和新特性</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-02T15:39:43+08:00">
                2015-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="标准模板库-STL"><a href="#标准模板库-STL" class="headerlink" title="标准模板库(STL)"></a>标准模板库(STL)</h2><ul>
<li>C++11所有容器类型: deque, list, queue, priority_queue, stack, vector, map, multimap, set, multiset, bitset(比特级处理数据的容器), forward_list(单向链表), unordered_map, unordered_multimap, unordered_set, unordered_multiset.<ul>
<li>vector是数组的一种表示, 提供了内存自动管理功能, 随着元素的增减而变化大小.<br>  在尾部添加或删除元素时间是固定的, 但在头部或中间添加或删除元素需要线性复杂度的时间<br>  vector 是序列也是可反转容器, 类方法rbegin()返回一个指向反转序列的第一个元素的迭代器, 因此可以用for_each( dice.rbegin(), dice.rend(), Show) 可以逆序输出vector对象dice.<br>  从vector中间插入删除元素, 迭代器指向的元素会变化</li>
<li>list 是双向链表, 与vector的关键区别在于, list在链表中的任意位置插入或删除时间都是固定的, 但不支持数组表示法和随机访问. 从链表中间插入删除元素, 迭代器指向的元素不变<br>  注意, 若list容器内装的是自定义类, 则上述几个函数都需要一个用来比较的函数作为参数</li>
<li>stack 栈, 底层类为vector, 不允许随机访问或遍历</li>
<li>queue 队列, 不允许随机访问或遍历<br>  注意pop是一个删除数据而不是检索数据(因为无返回值)的方法, 如要使用队列中的值应先使用front()检索再使用pop()删除</li>
<li>deque是双端队列, 在STL中实现类似于vector容器, 也支持随机访问(访问中间元素)<br>  主要区别: deque在队列头部或尾部(除了中间)插入删除元素时间也是固定的, 因此如果多数操作发生在队列头部或尾部则用deque</li>
<li>priority_queue优先队列模板类, 以vector为底层类, 与queue的主要区别在于, 最大(或最小)的元素被移到队首, 可以用构造函数 priority_queue<int> pq(greater<int>); 来构造一个最大元素…的优先队列, 其中greater&lt;&gt;()函数是一个预定义的函数对象</int></int></li>
<li>关联容器(set, map, multiset, multimap)基于树结构, 无序关联容器(unordered_set, unordered_multiset, unordered_map, unordered_multimap)基于哈希表结构, 提高了添加和删除元素的速度以及查找效率(散列查找)</li>
<li>注意array&lt;&gt;并非STL容器, 长度是固定的, 因此没有调整容器大小的操作(如push_back()和insert())</li>
</ul>
</li>
<li>自定义类型要存入map, set等内部需要按序存储的容器时, 需要重载 &lt; 运算符:<pre><code class="lang-cpp">  friend bool operator&lt;(const Point &amp; p1, const Point &amp; p2) {
      if ( p1.x != p2.x ) return p1.x &lt; p2.x;
      else if ( p1.y != p2.y ) return p1.y &lt; p2.y;
      else return p1.k &lt; p2.k;
  }
</code></pre>
  但是不能够简单写成 <pre><code class="lang-cpp">  return (p1.x &lt; p2.x &amp;&amp; p1.y &lt; p2.y &amp;&amp; p1.k &lt; p2.k);
</code></pre>
  这样写会导致map搜索元素时会把两个不完全相同的元素也认为是同一个元素</li>
<li>不能随便使用指针栈(如<code>stack&lt;char[40]&gt;</code>), 原因: Stack模板类中的操作对类型有所要求<br>  如果指针采用 char str[40]的形式存储, 由于传进Stack的Pop函数中的是char[40]类型的引用, 无法给str即数组名赋值, 因此将会无法Pop; 如果指针采用动态内存分配(new)存储, 即char* str = new char[40]; 则str存储的地址是固定的, 因此每次读取一个字符串进来都会在上一个字符串的地址重新覆盖原来读取的字符串, 因此每次压入栈的地址值都是一样的, 无意义<br>  解决方法: (调用者)用一个指针数组(字符串数组)存储每一次读进来的字符串)</li>
<li>容器的迭代器是一个容器内定义的成员类, 类似于循环中的循环变量, 如链表结构是以节点为单位的, 迭代器就是一个个节点(一般是一个指针), 迭代器进行自加运算则可以将迭代器指向下一个节点, 即iterator++ 被重载为了 iterator = iterator-&gt;next; 如vector类是数组实现的, 迭代器就是一个个指向数组某一个元素的指针, 迭代器++(即指针++)就可以将迭代器(指针)指向下一个元素</li>
<li>迭代器应该满足的特点:<ul>
<li>可以对迭代器执行解除引用操作, 具有*运算符重载</li>
<li>可以赋值, 具有赋值函数</li>
<li>可以比较看是否相等, 具有!=或==运算符重载</li>
<li>可以遍历容器中的所有元素, 具有++运算符重载(或可以实现+1效果的函数)</li>
</ul>
</li>
<li>迭代器的种类:<ul>
<li>随机访问迭代器:<ul>
<li>正向迭代器<ul>
<li>输入迭代器(只读)</li>
<li>输出迭代器(只写)</li>
</ul>
</li>
<li>反向迭代器<ul>
<li>输入迭代器(只读)</li>
<li>输出迭代器(只写)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>erase()函数删除vector中指定区间之间的元素, 如<pre><code class="lang-cpp">  vec.erase(vec.begin()+2,vec.begin()+3)
</code></pre>
  删除第二个元素, 即半开半闭区间[2,3)</li>
<li>insert()函数将一个vec中的区间插入到另一个vec的某一个元素<strong>前面</strong>, 如<pre><code class="lang-cpp">  // 将new_v的第二,三个元素插入到old_v第一个元素前面
  old_v( old_v.begin(), new_v.begin()+1, new_v.begin()+3)
</code></pre>
</li>
<li>模板使得算法独立于存储的数据类型, 迭代器使得算法独立于存储的容器类型(vector, map, set等等)</li>
<li><code>copy(arr, arr+10, new_vec)</code>的前两个迭代器(最好是输入迭代器)参数限定复制的范围, 第三个迭代器参数(最好是输出迭代器)说明复制到的位置(覆盖). 注意目标容器必须足够大, 因此不能用copy()把数据放到空vector中</li>
<li>输入输出流也有迭代器(类型为ostream_iterator和istream_iterator), 可以使用copy函数来完成输入和输出</li>
<li>函数符(也叫函数对象, 仿函数), 是可以以函数方式与()结合使用的任意对象, 包括函数名, 函数指针和重载了括号运算符的类对象(即定义了函数operator()()的类)。</li>
<li>函数符相关概念：<ul>
<li>生成器(generator)，是不用参数就可以调用的函数符。</li>
<li>一元函数(unary function)，是用一个参数可以调用的函数符(例如提供给for_each()的函数符应当是一元函数，因为它每次用于一个容器元素)。<ul>
<li>返回bool值的一元函数是 断言 (predicate)。</li>
</ul>
</li>
<li>二元函数(binary function)，是用两个参数可以调用的函数符。<ul>
<li>返回bool值的二元函数是 二元断言 (binary predicate)。</li>
</ul>
</li>
</ul>
</li>
<li>std::less<t> 是一种函数对象类型, 该类型所实例化得到的对象是类型T的 operator&lt; 方法</t></li>
<li>complex 头文件中包含了complex类, 用于表示复数</li>
<li>valarray 容器是专门用于处理数值运算(不是专门用于存储)的数组类型, 重载了加减乘除, 以及一些数学库内的数学函数(如log)。例如：<ul>
<li>对于valarray对象vint, <code>vint = log(vint);</code>或者<code>vint.apply(log);</code>语句可以使得vint数组内的每个元素都分别进行一次log运算；</li>
<li><code>vint = vint * vint;</code> 可以使得该数组内所有元素自乘一次. 但valarray不提供像vector那样的push_back等函数(因为其大小和array一样也是固定的)</li>
</ul>
</li>
<li>slice 是用作数组下标索引的一个对象, 构造方式为<code>slice slice1(1, 4, 3);</code> 其中1是起始下标, 4是索引数(选择的元素数), 3是跨度, ar[slice1]就表示ar[1], ar[1+3], ar[1+6], ar[1+9] 这四个元素.</li>
<li>C++11允许容器类用initializer_list<t>(这是一种类型)作为参数构造对象, 如<pre><code class="lang-cpp">  set&lt;string&gt; set1 = { &quot;ad&quot;, &quot;zxc&quot;, &quot;asd&quot; };     //注意这里必须用大括号, 大括号与其中的元素统称initializer_list
</code></pre>
  要注意使用这种方式初始化, 不能隐式地窄转换, 即不能够用<pre><code class="lang-cpp">  vector&lt;int&gt; vec = { 1, 2, 3.5 } // 3.5-&gt;3为窄转换
</code></pre>
</t></li>
<li>序列性容器(vector, string, list等) 使用erase(iterator)之后, 不仅使所有指向被删元素的迭代器失效, 而且使被删元素之后的所有迭代器失效(因为它们都是顺序存储的), 所以不能使用erase(iter++)的方式.<br>  可用方法:<ul>
<li>erase的返回值为下一个有效的迭代器, 所以在erase后, 可用原迭代器接受返回值(若不erase则还是++)<pre><code class="lang-cpp">for(string::iterator it=str.begin(); it!=str.end(); ){
  if( !isalpha(*it) ){
      it = str.erase(it);    // 也可以写成str.erase(it++);
  }else{
      it++;
  }
}
</code></pre>
</li>
<li>在erase掉之后, 可以用迭代器自减来使迭代器返回被erase掉的上一个迭代器位置(仍要接受erase返回值), 即<pre><code class="lang-cpp">for(string::iterator it=str.begin(); it!=str.end(); it++){
  if( !isalpha(*it) ){
      it = str.erase(it);
      it--;
  }
}
</code></pre>
而对于关联性容器(map,set等) 使用erase只是使得被删元素的迭代器失效, 而且erase函数返回void, 因此需要用erase(iter++)的方式来删除迭代器.<br>注: list容器两种方式都可以正常工作</li>
</ul>
</li>
<li>unique() 的返回值为指向处理完的容器的超尾元素( 即end() )的迭代器(若处理数组则为指向最后一个元素的下一个元素的指针), 因此可以用形如 unique(arr, arr+n) - arr 的表达式获得处理完的数组的大小<br>  实际上unique不会把元素erase掉, 只是遇到重复的元素就把后面的元素往前移<br>  想要用Unique删除重复元素的标准用法:<pre><code class="lang-cpp">  // 用erase + unique方法
  sort (Nodes.begin ( ), Nodes.end ( ));
  Nodes.erase (unique (Nodes.begin ( ), Nodes.end ( )), Nodes.end ( ));
  // 用s的构造函数 + vector.assign()方法
  set&lt;int&gt; s( vec.begin(), vec.end() );
  vec.assign( s.begin(), s.end() );
</code></pre>
  类似地, <code>lower_bound(arr, arr+n, targ)</code>返回值也是指向目标元素的地址或迭代器</li>
<li>STL Allocator:<pre><code>  1) alloc: 默认的分配器, 线程安全, 效率通常比较高
  2) pthread_alloc : 首先要知道pthread指的是POSIX线程, 即线程的POSIX标准, 定义了创建和操作线程的一套API
  同样是一个线程安全的分配器, 并且对于不同的线程使用不同的内存池, 使用前提是所在系统提供了pthreads
  通常比alloc要快, 尤其是在多处理器的系统中. 然而该分配器可能会引起资源碎片化 : 因为在一个线程中deallocated(即free掉的)内存是无法被其他线程来使用的.
  3) single_client_alloc : 快速但不保证线程安全的分配器, 因此只适用于单线程的程序中, 可能比alloc更快
</code></pre>malloc_alloc : 该分配器是用标准库的malloc函数来分配内存的, 保证线程安全但通常比较慢, 主要用于调试时</li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul>
<li><code>template&lt;typename T, int n&gt;</code><br>其中T为类型参数, n称为非类型参数<br>非类型模板参数(类似于模板类的静态常量)规定的类型只能传入常量, 允许的类型包括<ul>
<li>整型和枚举类型</li>
<li>对象或函数的指针</li>
<li>对象或函数的左值引用</li>
<li>成员指针</li>
<li>nullptr_t<br>因此不能是某个类类型, 即便是string类型也不能作为非类型模板参数的类型, 即<pre><code class="lang-cpp">&lt;string str&gt;
void func(){}
</code></pre>
是无法通过编译的</li>
</ul>
</li>
<li>在代码中包含函数模板本身并不会生成函数定义, 它只是一个用于生成函数定义的方案; 编译器使用模板为特定类型生成函数定义时, 得到的是模板实例</li>
<li>显式具体化(explicit specialization): 也称显式特化, 在使用模板时, 对于某些特定的类型, 需要提供一个不同于一般类型的具体化函数定义, 称为显式具体化. 当编译器找到与函数调用匹配的具体化定义时, 将使用该定义, 而不再寻找模板。<br>  显式具体化的原型和定义应以template &lt;&gt;开头, 并在后面通过名称来指出类型, 如以下定义:<pre><code class="lang-cpp">  template &lt;&gt; swap&lt;job&gt;(job &amp;, job &amp;){};     // 显式具体化swap&lt;T&gt;模板函数
  // 也可以简写成template &lt;&gt; swap(job &amp;, job &amp;){};
</code></pre>
  注意：<ol>
<li>具体化优先于常规模板, 而非模板函数优先于具体化和常规模板</li>
<li>具体化(特化, specialization)和实例化(instantiation)的区别<br>“具体化”指的是存在具体类型的函数定义(非声明), “实例化”指的是函数被实际地调用了, 如显式实例化:<pre><code class="lang-cpp">swap&lt;job&gt;(a,b); // Swap为模板函数
</code></pre>
</li>
</ol>
</li>
<li>在一个模板函数(或模板类的方法定义)中, 形如<code>vector&lt;T&gt;::iterator it;</code>这样的声明无法通过编译,而<code>vector&lt;int&gt;::iterator it;</code>这样的声明却可以通过.<br>  这是因为在vector<t>未实例化之前是一个dependent scope而非一个类型, 即是一个需要depend on instantiation的scope(其实关键在于特化, 因为如果没有指明T是哪个具体的类型, 编译器就无法确定vector<t>这个模板是否有被这种类型特化, 并在特化的scope中把iterator这个关键字重新定义为其他变量);<br>  而vector<int>是一个实例化了的具体的类型, 因此编译器无法确定在这个vector<t>这个scope中iterator这个名称指的是一个成员变量还是类型(编译器会优先认为是变量), 却可以确定vector<int>这个类型中的iterator是一个类型</int></t></int></t></t></li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/迷途指针" target="_blank" rel="noopener">野指针(悬挂指针)</a>: 指向一个已删除的对象或未申请访问受限内存区域的指针。成因:<ul>
<li>指针变量未初始化</li>
<li>指针释放后之后未置空</li>
<li>指针操作超过变量作用域</li>
<li>realloc函数使用不当:<pre><code class="lang-cpp">  #include&lt;malloc.h&gt;
  int main(){
      char *p, *q;
      p = (char*)malloc(10);
      q = p;
      p = (char*)realloc(q, 20);
      //…………………………
  }
</code></pre>
  在这段程序中我们用q记录原来的内存地址p。这段程序可以编译通过，但在执行到<code>realloc(q, 20)</code>时，若原内存后面没有足够空间来将原有空间扩展成一个连续的新大小，那么realloc函数会从堆中重新找一块30字节大小的内存，并把原来（通过调用malloc函数得到的）内存空间中的内容复制到这块新内存中，此时数据发生了移动，那么q所指向（通过调用malloc函数得到的）的内存空间实际上已经放回到堆上了，这样就会产生q指针的指针悬挂</li>
</ul>
</li>
<li>常规指针不能隐式地转换为智能指针, 因为智能指针的构造函数的声明是explicit的</li>
<li>错误的用法:<pre><code class="lang-cpp">  string str(&quot;this is a test&quot;);
  auto_ptr&lt;string&gt; ptr(&amp;str);
</code></pre>
  原因: 智能指针指向的内存是存放于堆区的(静态变量), 一般情况下应该用new来动态内存分配<br>  但是这里的str显然是存放于栈区的, 该段代码结束后会自动释放, 而同样在栈区的智能指针析构时也会释放, 造成二次释放<br>  (同样也不能使得两个智能指针指向同一个地址, 也会造成二次释放)<br>  上述语句可以改用 <code>auto_ptr&lt;string&gt; ptr(new string(&quot;this is a test&quot;));</code>来实现<br>  <strong>shared_ptr和unique_ptr都解决了上述auto_ptr导致的多重所有权多次释放的问题</strong></li>
<li>unique_ptr允许语句 <code>unique_ptr p2 = unique_ptr( new string(&quot;this&quot;) );</code><br>  即若unique_ptr是一个临时右值, 则允许两个unique_ptr临时指向同一个地址<br>  但不允许将悬挂的unique_ptr赋值给其他的unique_ptr, 如<pre><code class="lang-cpp">  unique_ptr p1(new string(&quot;this&quot;));    // 创建了一个悬挂的unique_ptr
  unique_ptr p2 = p1;
</code></pre>
  这是<strong>无法通过编译</strong>的<br>  实际上unique_ptr禁止一切按值传递操作, 要想转移所有权, 必须通过std::move()或unique_ptr::release(), reset()等其他函数</li>
<li>unique_ptr比auto_ptr还有一个优点, 可以与new []一起使用, 因为auto_ptr只有delete一个版本而没有delete [], 而unique_ptr具有两个版本, 如可以使用<br>  unique_ptr<double []=""> pda(new double(5));</double></li>
<li>智能指针的选择:<br>  如果程序要使用多个指针同时指向一个对象, 则用shared_ptr, 否则用unique_ptr</li>
<li>STL string类的COW(copy-on-write)特性:<pre><code class="lang-cpp">  string str1 = &quot;hello world&quot;; 
  string str2 = str1; 
  printf (&quot;Sharing the memory:\n&quot;); 
  printf (&quot;\tstr1&#39;s address: %x\n&quot;, str1.c_str() ); 
  printf (&quot;\tstr2&#39;s address: %x\n&quot;, str2.c_str() ); 
  str1[1]=&#39;q&#39;; 
  str2[1]=&#39;w&#39;; 
  printf (&quot;After Copy-On-Write:\n&quot;); 
  printf (&quot;\tstr1&#39;s address: %x\n&quot;, str1.c_str() ); 
  printf (&quot;\tstr2&#39;s address: %x\n&quot;, str2.c_str() );
</code></pre>
  输出:<pre><code>  Sharing the memory: 
  str1&#39;s address: 343be9 
  str2&#39;s address: 343be9 
  After Copy-On-Write: 
  str1&#39;s address: 3407a9 
  str2&#39;s address: 343be9
</code></pre>  实现原理 : 引用计数</li>
</ul>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul>
<li>Lambda的组成部分:  <img src="/笔记/C-学习笔记-标准模板库和新特性/lambda_expression.png">
<ul>
<li>Capture 子句（在 C++ 规范中也称为 lambda 引导。）</li>
<li>参数列表（可选）。 （也称为 lambda 声明符)</li>
<li>可变规范（可选）。</li>
<li>异常规范（可选）。</li>
<li>尾随返回类型（可选）。</li>
<li>“lambda 体”</li>
</ul>
</li>
<li>常见的语言（如C#）会自动为Lambda捕获当前上下文的所有变量，但C++要求我们在Lambda的捕获子句里显式指定想要捕获的变量以及捕获的形式(按值和引用)，否则无法在函数体里使用这些变量。如果捕获子句里面什么都不写，编译器会认为我们不需要捕获任何变量</li>
<li>如果希望按引用传递捕获当前上下文的所有变量，可以把捕获子句写成[&amp;]；如果你希望按值传递捕获当前上下文的所有变量，可以把捕获子句写成[=]。<br>  如果希望把按引用传递设为默认的传递方式，同时指定个别变量按值传递，可以把捕获子句写成[&amp;, a, b]</li>
<li>按值传递在声明Lambda的那一刻就已经确定变量的值了，无论之后外面怎么修改，里面只能访问到声明时传过来的版本；而按引用传递则刚好相反</li>
<li>只有两种情况可以省略lambda表达式的返回值:<pre><code>  1. 无返回值
  2. 函数体只包含一条返回语句
</code></pre></li>
<li>用lambda实现递归函数时, 需要把定义和声明语句分开写, 并在capture子句中捕获该变量:<pre><code class="lang-cpp">  std::function&lt; void(std::vector&lt;T&gt; &amp;, int, int) &gt; quickSort;
  quickSort =
      [&amp;quickSort] (std::vector&lt;T&gt; &amp; arr, int left, int right) {
      // ...
      quickSort(arr, left, li - 1);
      quickSort(arr, li + 1, right);
  };
</code></pre>
</li>
<li>应用场景示例: map 容器根据value值排序:<pre><code class="lang-cpp">  vector&lt; pair&lt;char, int&gt; &gt; tmpVec(myMap.begin(), myMap.end());
  sort(tmpVec.begin(), tmpVec.end(), 
  [=](const pair&lt;char, int&gt; &amp; p1, const pair&lt;char, int&gt; &amp; p2){            // 传入匿名函数作为比较器
      return p1.second &gt; p2.second; 
  } );
</code></pre>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>四种新的类型转换操作符(称为标准转换运算符, 主要用于类指针的转换):<ul>
<li>static_cast<new_type>(expression) :<ul>
<li>把expression转换为new_type类型, 但没有运行时类型检查来保证安全性(安全性指的是, 若转换一个指针后得到的新指针指向的内存宽度与原来的不同, 安全的类型转换会自动将新指针置为nullptr, 而不安全的类型转换就不会管这个, 从而对新指针指向的某些成员进行访问时就可能会造成访问越界 (比如把基类指针转换为子类指针时就可能出现这个问题) )</li>
<li>也可以用于基本数据类型之间的转换, 此时相当于C风格的强制转换</li>
<li>static_cast不能转换掉expression的const、volitale、或者__unaligned属性。</li>
</ul>
</new_type></li>
<li>dynamic_cast<new_type>(expression) :<ul>
<li>较常用, 与static_cast相对的一个操作符, 保证安全性, 若转换后有可能出现不安全的访问则将返回nullptr(因此也可以用于判断类之间是否可相互转换)</li>
<li>new_type和expression必须是有关联的, 如new_type是指针/引用, expression也必须为指针/引用..(否则无法通过编译)<ul>
<li>reinterpret_cast<new_type>(expression)</new_type></li>
</ul>
</li>
<li>type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。</li>
<li>可以把一个指针转换成一个整数(即地址值)，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值）。<ul>
<li>const_cast<new_type>(expression)</new_type></li>
</ul>
</li>
<li>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。</li>
</ul>
</new_type></li>
</ul>
</li>
<li>左值引用, 右值引用<br>概念理解:l-value可以理解为location-value, 在内存中拥有固定地址的东西, 包括所有类型的变量或变量表达式(如 i = 0 这个表达式)<br>右值可以理解为readonly-value 即除了左值以外的, 一个临时的值, 包括所有字面量(常量及常量字符串)和常量表达式(如1+2), 以及临时对象:如用 myClass() 产生的临时对象</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/Programming-Language/" rel="tag"># Programming Language</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/笔记/C-学习笔记-面向对象/" rel="next" title="C++学习笔记-面向对象">
                <i class="fa fa-chevron-left"></i> C++学习笔记-面向对象
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/笔记/分布式块存储系统sheepdog学习笔记/" rel="prev" title="分布式块存储系统sheepdog学习笔记">
                分布式块存储系统sheepdog学习笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Stardust</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#标准模板库-STL"><span class="nav-number">1.</span> <span class="nav-text">标准模板库(STL)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模板"><span class="nav-number">2.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#智能指针"><span class="nav-number">3.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda表达式"><span class="nav-number">4.</span> <span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">5.</span> <span class="nav-text">其他</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stardust</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
